class g{constructor(t){if(t.height!==1||t.width!==1)throw"Pixel: error, must be created from a 1x1 ImageData";this.r=t.data[0],this.g=t.data[1],this.b=t.data[2],this.a=t.data[3]}toHex(){var t=this._getHexFromNumber(this.r),e=this._getHexFromNumber(this.g),i=this._getHexFromNumber(this.b);return`#${t}${e}${i}`}_getHexFromNumber(t){return parseInt(t,10).toString(16).slice(-2)}}class l{constructor({url:t,height:e=200,width:i=200}){this.url=t,this.height=e,this.width=i}read(){return this._createAndLoadImage().then(t=>(this._createCanvasFromImage(t),this))}pixelAt(t=0,e=0){if(!this._context)throw"ImageReader: image is still not ready";return t=Math.round(t),t=Math.max(0,t),t=Math.min(this.width,t),e=Math.round(e),e=Math.max(0,e),e=Math.min(this.height,e),new g(this._context.getImageData(t,e,1,1))}pixelAtPercentage(t=0,e=0){const i=t/100*this.width,n=e/100*this.height;return this.pixelAt(i,n)}_createAndLoadImage(){return new Promise((t,e)=>{this.img=new Image,this.img.style.width=`${this.width}px`,this.img.style.height=`${this.height}px`,this.img.width=this.width,this.img.height=this.height,this.img.style.objectFit="cover",this.img.onload=()=>{t(this.img)},this.img.onerror=i=>{e(i)},this.img.src=this.url})}_createCanvasFromImage(t){const e=document.createElement("canvas");e.style.display="block",e.width=this.width,e.height=this.height,this._context=e.getContext("2d"),this._context.drawImage(t,0,0)}}class o{constructor(t,e){this.point1=t,this.point2=e}get length(){return Math.sqrt((this.point1.x-this.point2.x)*(this.point1.x-this.point2.x)+(this.point1.y-this.point2.y)*(this.point1.y-this.point2.y))}getMiddlePoint(){return{x:(this.point1.x+this.point2.x)/2,y:(this.point1.y+this.point2.y)/2}}}class m{constructor(t){this.points=t,this.segments=[new o(t[0],t[1]),new o(t[1],t[2]),new o(t[2],t[0])]}divideByTwo(){const{longest:t,others:e}=this.getLongestSegment(),i=t.getMiddlePoint();return[[i,e[0].point1,e[0].point2],[i,e[1].point1,e[1].point2]]}getLongestSegment(){let t=0,e=this.segments[0].length;for(let i=0;i<this.segments.length;i++){const n=this.segments[i].length;n>e&&(t=i,e=n)}return{longest:this.segments[t],others:this.segments.filter((i,n)=>n!==t)}}}const c="http://www.w3.org/2000/svg",d="#a1a1a1";class r{constructor({points:t,referenceImage:e}){if(!t||t.length!==3)throw"SVGTriangle: must provide 3 points";this._points=t,this._referenceImage=e,this._element=this._createElementFromPoints(t);const i=this._getColorFromImageAtCenter(e,t);this._applyColorToElement(i,this._element)}get element(){return this._element}divideByTwo(){const[t,e]=new m(this._points).divideByTwo();return[new r({points:t,referenceImage:this._referenceImage}),new r({points:e,referenceImage:this._referenceImage})]}destroy(){this._element&&this._element.parentNode&&this._element.parentNode.removeChild(this._element),this._element=null}_createElementFromPoints(t){const e=document.createElementNS(c,"polygon");e.setAttribute("stroke-width","0");const i=t.map(n=>`${n.x},${n.y}`).join(" ");return e.setAttribute("points",i),e}_getColorFromImageAtCenter(t,e){if(!t)return d;const i=this._getCenterOf(e);return t.pixelAtPercentage(i.x,i.y).toHex()}_applyColorToElement(t,e){e.setAttribute("fill",t)}_getCenterOf(t){return{x:(t[0].x+t[1].x+t[2].x)/3,y:(t[0].y+t[1].y+t[2].y)/3}}}const h=2e4,_=2,a=200,u=2,x=25;class w{constructor({url:t,svg:e}){this._svg=e,new l({url:t}).read().then(n=>{this.startTriangulating(n)},n=>{console.warn(`Triangulator: error loading ${t}`)})}startTriangulating(t){this.triangles=[];const e=new r({points:[{x:0,y:0},{x:100,y:0},{x:0,y:100}],referenceImage:t}),i=new r({points:[{x:100,y:100},{x:100,y:0},{x:0,y:100}],referenceImage:t});this._addTriangle(e),this._addTriangle(i),this.iterations=1,this._triangulateNext()}_addTriangle(t){this._svg.appendChild(t.element),this.triangles.push(t)}_triangulateNext(){if(this.triangles&&this.iterations<h){for(let t=0;t<x;t++)this.iterations++,this._makeOneDivision();window.setTimeout(()=>{window.requestAnimationFrame(()=>this._triangulateNext())},this._getGenerationTime())}}_makeOneDivision(){const t=this._extractNextTriangle(),[e,i]=t.divideByTwo();t.destroy(),this._addTriangle(e),this._addTriangle(i)}_getGenerationTime(){return a+(u-a)*(this.iterations/h)}_extractNextTriangle(){const t=Math.min(this.triangles.length,_),e=Math.floor(Math.random()*t);return this.triangles.splice(e,1)[0]}}const p=({url:s,svg:t})=>{if(!s||!t)throw"ERROR: triangulator must receive a url and a svg container";return new w({url:s,svg:t})};export{p as triangulator};
