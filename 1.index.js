(window.webpackJsonp=window.webpackJsonp||[]).push([[1],{6:function(t,e,i){"use strict";i.r(e),i.d(e,"triangulator",(function(){return l}));var s=class{constructor(t){if(1!==t.height||1!==t.width)throw"Pixel: error, must be created from a 1x1 ImageData";this.r=t.data[0],this.g=t.data[1],this.b=t.data[2],this.a=t.data[3]}toHex(){return`#${this._getHexFromNumber(this.r)}${this._getHexFromNumber(this.g)}${this._getHexFromNumber(this.b)}`}_getHexFromNumber(t){return parseInt(t,10).toString(16).slice(-2)}};var n=class{constructor({url:t,height:e=200,width:i=200}){this.url=t,this.height=e,this.width=i}read(){return this._createAndLoadImage().then(t=>(this._createCanvasFromImage(t),this))}pixelAt(t=0,e=0){if(!this._context)throw"ImageReader: image is still not ready";return t=Math.round(t),t=Math.max(0,t),t=Math.min(this.width,t),e=Math.round(e),e=Math.max(0,e),e=Math.min(this.height,e),new s(this._context.getImageData(t,e,1,1))}pixelAtPercentage(t=0,e=0){const i=t/100*this.width,s=e/100*this.height;return this.pixelAt(i,s)}_createAndLoadImage(){return new Promise((t,e)=>{this.img=new Image,this.img.style.width=this.width+"px",this.img.style.height=this.height+"px",this.img.width=this.width,this.img.height=this.height,this.img.style.objectFit="cover",this.img.onload=()=>{t(this.img)},this.img.onerror=t=>{e(t)},this.img.src=this.url})}_createCanvasFromImage(t){const e=document.createElement("canvas");e.style.display="block",e.width=this.width,e.height=this.height,this._context=e.getContext("2d"),this._context.drawImage(t,0,0)}};class r{constructor(t,e){this.point1=t,this.point2=e}get length(){return Math.sqrt((this.point1.x-this.point2.x)*(this.point1.x-this.point2.x)+(this.point1.y-this.point2.y)*(this.point1.y-this.point2.y))}getMiddlePoint(){return{x:(this.point1.x+this.point2.x)/2,y:(this.point1.y+this.point2.y)/2}}}var h=class{constructor(t){this.points=t,this.segments=[new r(t[0],t[1]),new r(t[1],t[2]),new r(t[2],t[0])]}divideByTwo(){const{longest:t,others:e}=this.getLongestSegment(),i=t.getMiddlePoint();return[[i,e[0].point1,e[0].point2],[i,e[1].point1,e[1].point2]]}getLongestSegment(){let t=0,e=this.segments[0].length;for(let i=0;i<this.segments.length;i++){const s=this.segments[i].length;s>e&&(t=i,e=s)}return{longest:this.segments[t],others:this.segments.filter((e,i)=>i!==t)}}};class o{constructor({points:t,referenceImage:e}){if(!t||3!==t.length)throw"SVGTriangle: must provide 3 points";this._points=t,this._referenceImage=e,this._element=this._createElementFromPoints(t);const i=this._getColorFromImageAtCenter(e,t);this._applyColorToElement(i,this._element)}get element(){return this._element}divideByTwo(){const[t,e]=new h(this._points).divideByTwo();return[new o({points:t,referenceImage:this._referenceImage}),new o({points:e,referenceImage:this._referenceImage})]}destroy(){this._element&&this._element.parentNode&&this._element.parentNode.removeChild(this._element),this._element=null}_createElementFromPoints(t){const e=document.createElementNS("http://www.w3.org/2000/svg","polygon");e.setAttribute("stroke-width","0");const i=t.map(t=>`${t.x},${t.y}`).join(" ");return e.setAttribute("points",i),e}_getColorFromImageAtCenter(t,e){if(!t)return"#a1a1a1";const i=this._getCenterOf(e);return t.pixelAtPercentage(i.x,i.y).toHex()}_applyColorToElement(t,e){e.setAttribute("fill",t)}_getCenterOf(t){return{x:(t[0].x+t[1].x+t[2].x)/3,y:(t[0].y+t[1].y+t[2].y)/3}}}var a=o;var g=class{constructor({url:t,svg:e}){this._svg=e,new n({url:t}).read().then(t=>{this.startTriangulating(t)},e=>{console.warn("Triangulator: error loading "+t)})}startTriangulating(t){this.triangles=[];const e=new a({points:[{x:0,y:0},{x:100,y:0},{x:0,y:100}],referenceImage:t}),i=new a({points:[{x:100,y:100},{x:100,y:0},{x:0,y:100}],referenceImage:t});this._addTriangle(e),this._addTriangle(i),this.iterations=1,this._triangulateNext()}_addTriangle(t){this._svg.appendChild(t.element),this.triangles.push(t)}_triangulateNext(){if(this.triangles&&this.iterations<2e4){for(let t=0;t<25;t++)this.iterations++,this._makeOneDivision();window.setTimeout(()=>{window.requestAnimationFrame(()=>this._triangulateNext())},this._getGenerationTime())}}_makeOneDivision(){const t=this._extractNextTriangle(),[e,i]=t.divideByTwo();t.destroy(),this._addTriangle(e),this._addTriangle(i)}_getGenerationTime(){return 200+this.iterations/2e4*-198}_extractNextTriangle(){const t=Math.min(this.triangles.length,2),e=Math.floor(Math.random()*t);return this.triangles.splice(e,1)[0]}};const l=({url:t,svg:e})=>{if(!t||!e)throw"ERROR: triangulator must receive a url and a svg container";return new g({url:t,svg:e})}}}]);